{"ast":null,"code":"function makeNodeArray(rows, columns) {\n  let initNode = [];\n\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < columns; j++) {\n      initNode.push({\n        id: i + \"_\" + j,\n        type: \"EMPTY\",\n        callingnode: \"\"\n      });\n    }\n  }\n\n  return initNode;\n}\n\nconst initState = {\n  nodes: makeNodeArray(15, 20),\n  isActive: {\n    wall: false,\n    startFinNode: false,\n    algorithm: \"Null\",\n    start: false\n  }\n};\n\nconst rootReducer = (state = initState, action) => {\n  if (action.type === \"WALL_STATUS_CHANGE\") {\n    let newWall = state.isActive.wall ? false : true;\n    return { ...state,\n      isActive: { ...state.isActive,\n        startFinNode: false,\n        wall: newWall\n      } //want to change the other types of block\n\n    };\n  } else if (action.type === \"START_FINISH_NODE\") {\n    let newSFNodes = state.isActive.startFinNode ? false : true;\n    return { ...state,\n      isActive: { ...state.isActive,\n        startFinNode: newSFNodes,\n        wall: false\n      }\n    };\n  } else if (action.type === \"TYPE_CHANGE\") {\n    //seeing how many sf nodes there are in the map\n    let newNodes = state.nodes.map(node => {\n      if (action.id === node.id && state.isActive.wall === true) {\n        return { ...node,\n          type: \"WALL\"\n        };\n      } else if (action.id === node.id && state.isActive.startFinNode === true && state.nodes.filter(node => {\n        return node.type === \"SFNODE\";\n      }).length < 2) {\n        return node.type === \"SFNODE\" ? { ...node,\n          type: \"EMPTY\",\n          noOfSFNodes: state.isActive.noOfSFNodes--\n        } : { ...node,\n          type: \"SFNODE\",\n          noOfSFNodes: state.isActive.noOfSFNodes++\n        };\n      }\n\n      return node;\n    });\n    return { ...state,\n      nodes: newNodes\n    };\n  } else {\n    return state;\n  }\n};\n\nexport default rootReducer;","map":{"version":3,"sources":["C:/Users/geoff/Desktop/AlgorithmVisualizer/AlgorithmVisualizer/myapp/src/reducers/rootReducer.js"],"names":["makeNodeArray","rows","columns","initNode","i","j","push","id","type","callingnode","initState","nodes","isActive","wall","startFinNode","algorithm","start","rootReducer","state","action","newWall","newSFNodes","newNodes","map","node","filter","length","noOfSFNodes"],"mappings":"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","sourcesContent":["function makeNodeArray(rows, columns) {\r\n  let initNode = [];\r\n  for (let i = 0; i < rows; i++) {\r\n    for (let j = 0; j < columns; j++) {\r\n      initNode.push({ id: i + \"_\" + j, type: \"EMPTY\", callingnode: \"\" });\r\n    }\r\n  }\r\n  return initNode;\r\n}\r\n\r\nconst initState = {\r\n  nodes: makeNodeArray(15, 20),\r\n  isActive: {\r\n    wall: false,\r\n    startFinNode: false,\r\n    algorithm: \"Null\",\r\n    start: false\r\n  }\r\n};\r\n\r\nconst rootReducer = (state = initState, action) => {\r\n  if (action.type === \"WALL_STATUS_CHANGE\") {\r\n    let newWall = state.isActive.wall ? false : true;\r\n    return {\r\n      ...state,\r\n      isActive: { ...state.isActive, startFinNode: false, wall: newWall } //want to change the other types of block\r\n    };\r\n  } else if (action.type === \"START_FINISH_NODE\") {\r\n    let newSFNodes = state.isActive.startFinNode ? false : true;\r\n    return {\r\n      ...state,\r\n      isActive: { ...state.isActive, startFinNode: newSFNodes, wall: false }\r\n    };\r\n  } else if (action.type === \"TYPE_CHANGE\") {\r\n    //seeing how many sf nodes there are in the map\r\n    let newNodes = state.nodes.map(node => {\r\n      if (action.id === node.id && state.isActive.wall === true) {\r\n        return { ...node, type: \"WALL\" };\r\n      } else if (\r\n        action.id === node.id &&\r\n        state.isActive.startFinNode === true &&\r\n        state.nodes.filter(node => {\r\n          return node.type === \"SFNODE\";\r\n        }).length < 2\r\n      ) {\r\n        return node.type === \"SFNODE\"\r\n          ? {\r\n              ...node,\r\n              type: \"EMPTY\",\r\n              noOfSFNodes: state.isActive.noOfSFNodes--\r\n            }\r\n          : {\r\n              ...node,\r\n              type: \"SFNODE\",\r\n              noOfSFNodes: state.isActive.noOfSFNodes++\r\n            };\r\n      }\r\n\r\n      return node;\r\n    });\r\n    return { ...state, nodes: newNodes };\r\n  } else {\r\n    return state;\r\n  }\r\n};\r\n\r\nexport default rootReducer;\r\n"]},"metadata":{},"sourceType":"module"}